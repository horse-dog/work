## 二进制中1的个数

--------------------

- 编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为 汉明重量).）。

- 答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

--------------------

- 示例 1：
    
    - 输入：n = 11 (控制台输入 00000000000000000000000000001011)
    
    - 输出：3

    - 解释：输入的二进制串 00000000000000000000000000001011 中，共有三位为 '1'。

--------------------

- 限制：

    - 输入必须是长度为 32 的 二进制串 。

--------------------

- 方法一：逐位统计

- 时间复杂度：O(K)，K 为 int 型的二进制位数

```cpp
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int count = 0;
        while (n != 0) {
            if (n & 1) ++count;
            n >>= 1;
        }
        return count;
    }
};

```
--------------------

- 方法二：布赖恩·克尼根算法

- 时间复杂度：O(logn)。循环次数等于 n 的二进制位中 1 的个数，最坏情况下 n 的二进制位全部为 1。我们需要循环 logn 次。

```txt
      n = 1 0 1 0 1 0 0 0
    n-1 = 1 0 1 0 0 1 1 1
n&(n-1) = 1 0 1 0 0 0 0 0
```
- 每进行一次 `n&(n-1)` 运算，就会去除最右边的1

```cpp
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int count = 0;
        while (n != 0) {
            n &= (n - 1);
            ++count;
        }
        return count;
    }
};
```
--------------------

- 方法三：二分法

```txt
n = 1 0 1 1 0 0 1 1  # 每一位代表对应一位1的个数：1:0:1:1:0:0:1:1

n = 1 0 1 1 0 0 1 1     n >> 1: 0 1 0 1 1 0 0 1
    0 0 0 1 0 0 0 1             0 1 0 1 0 0 0 1 # 每两位取低一位

    0 0 0 1 0 0 0 1
    0 1 0 1 0 0 0 1
  +
  -----------------
n = 0 1 1 0 0 0 1 0  # 每两位代表对应两位1的个数：1:2:0:2

n = 0 1 1 0 0 0 1 0     n >> 2: 0 0 0 1 1 0 0 0
    0 0 1 0 0 0 1 0             0 0 0 1 0 0 0 0 # 每四位取低两位

    0 0 1 0 0 0 1 0
  + 0 0 0 1 0 0 0 0
  -----------------
n = 0 0 1 1 0 0 1 0  # 每四位代表对应四位1的个数：3:2

n = 0 0 1 1 0 0 1 0     n >> 4: 0 0 0 0 0 0 1 1
    0 0 0 0 0 0 1 0             0 0 0 0 0 0 1 1 # 每八位取低四位

    0 0 0 0 0 0 1 0
  + 0 0 0 0 0 0 1 1
  -----------------
n = 0 0 0 0 0 1 0 1  # 每八位代表对应八位1的个数：5

ret 5
```

```cpp
class Solution {
public:
    int hammingWeight(uint32_t n) {
        n = (n & 0x55555555) + ((n >> 1) & 0x55555555);
        n = (n & 0x33333333) + ((n >> 2) & 0x33333333);
        n = (n & 0x0F0F0F0F) + ((n >> 4) & 0x0F0F0F0F);
        n = (n & 0x00FF00FF) + ((n >> 8) & 0x00FF00FF);
        n = (n & 0x0000FFFF) + ((n >> 16) & 0x0000FFFF);
        return n;
    }
};
```

--------------------

- 方法四：统计表法

- 把1个字节（8位）,每个数字(0~255)所对于的个数记录下来，一直查表就可以了。

```cpp
class Solution {
    char poptable [256] =
    {   0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
    };
public:
    int hammingWeight(uint32_t n) {
        return poptable[n & 0xFF] 
             + poptable[(n >> 8) & 0xFF] 
             + poptable[(n >> 16) & 0xFF] 
             + poptable[(n >> 24) & 0xFF];
    }
};
```