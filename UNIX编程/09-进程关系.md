## 1 引言
- 每个进程都有一个父进程（初始的内核级进程通常是自己的父进程）。
- 父进程能够得到通知并能取得子进程的退出状态。
- `waitpid` 可以等待进程组中任意一个进程终止。

## 2 终端登录
- 系统管理创建通常名为 `/etc/ttys/` 的文件，其中，每个终端设备都有一行，每一行说明设备名和传到 `getty` 程序的参数。
- 当系统自举时，内核创建进程 `ID` 为 1 的进程，也就是 `init` 进程。
  - `init` 进程使系统进入多用户模式。
  - `init` 读取文件 `/etc/ttys`，对每一个允许登录的终端设备，`init` 调用一次 `fork`，它所生成的子进程则 `exec getty` 程序。
    - `getty` 对终端设备调用 `open` 函数，以读、写方式将终端打开。
    - 一旦设备被打开，则文件描述符 0、1、2 就被设置到该设备。
    - 然后 `getty` 输出 `"login:"` 之类的信息，并等待用户键入用户名。
    - 当用户键入了用户名后，`getty` 的工作就完成了。
    - 然后它以类似于下列的方式调用 `login` 程序:

      ```cpp
      execle("/bin/login", "login", "-p", username, (char *)0, envp);
      ```
    - `-p` 标志通知 `login` 保留传递给它的环境，也可将其他环境字符串加到该环境中，但是不要替换它。
- `login` 能处理多项工作。
    - 因为它得到了用户名，所以能调用 `getpwnam` 取得相应用户的口令文件登录项。
    - 然后调用 `getpass` 以显示提示 `"Password:"`，接着读用户键入的口令。
    - 它调用 `crypt` 将用户键入的口令加密，并与该用户在阴影口令文件中登录项的 `pw_passwd` 字段相比较。
    - 如果用户几次键入的口令都无效，则 `login` 以参数 1 调用 `exit` 表示登录过程失败。
    - 父进程（`init`）了解到子进程的终止情况后，将再次调用 `fork`，其后又执行了 `getty`，对此终端重复上述过程。
- 如果用户正确登录，`login` 就将完成如下工作:
    - 将当前工作目录更改为该用户的起始目录（`chdir`）。
    - 调用 `chown` 更改该终端的所有权，使登录用户成为它的所有者。
    - 将对该终端设备的访问权限改变成"用户读和写"。
    - 调用 `setgid` 及 `initgroups` 设置进程的组 ID。
    - 用 `login` 得到的所有信息初始化环境：起始目录（`HOME`）、`shell`（`SHELL`）、用户名（`USER` 和 `LOGNAME`）以及一个系统默认路径（`PATH`）。
    - `login` 进程更改为登录用户的用户 `ID`（`setuid`）并调用该用户的登录 `shell`，其方式类似于:

        ```cpp
        execl("/bin/sh", "-sh", (char *)0);
        ```

## 3 网络登录
- 在 `BSD` 中，有一个 `inetd` 进程（有时称为因特网超级服务器），它等待大多数网络连接。
- 作为系统启动的一部分，`init` 调用一个 `shell`，使其执行 `shell` 脚本 `/etc/rc`。
- 由此 `shell` 脚本启动一个守护进程 `inetd`。
- 一旦此 `shell` 脚本终止，`inetd` 的父进程就变成 `init`。
- `inetd` 等待 `TCP/IP` 连接请求到达主机，而当一个连接请求到达时，它执行一次 `fork`，然后生成的子进程 `exec` 适当的程序。

## 4 进程组
- 每个进程除了有一个进程 ID 之外，还属于一个进程组。
- 进程组是一个或多个进程的集合。通常，它们是在同一作业中结合起来的。
- 同一进程组中的各进程接收来自同一终端的各种信号。
- 每个进程组有一个唯一的进程组 ID。进程组 ID 类似于进程 ID——它是一个正整数，并可存放在 pid_t 数据类型中。

    ```cpp
    #include <unistd.h>
    pid_t gitpgrp(void);
    // 返回值：调用进程的进程组 ID
    
    pid_t getpgid(pid_t pid);
    // 返回值：若成功，返回进程组 ID；若出错，返回 -1
    ```
- 对于函数 `getpgid`, 若 `pid` 是 0，返回调用进程的进程组 ID，于是，`getpgid(0)` 等价于 `getpgrp()`。
- 进程调用 `setpgid` 可以加入一个现有的进程组或者创建一个新进程组：

    ```cpp
    #include <unistd.h>
    int setpgid(pid_t pid, pid_t pgid);
    // 返回值：若成功，返回 0；若出错，返回 -1
    ```
    - `setpgid` 函数将 `pid` 进程的进程组 ID 设置为 `pgid`。
    - 如果这两个参数相等，则由 `pid` 指定的进程变成进程组组长。
    - 如果 `pid` 是 0，则使用调用者的进程 ID。
    - 如果 `pgid` 是 0，则由 `pid` 指定的进程 ID 用作进程组 ID。
    - 一个进程只能为它自己或它的子进程设置进程组 ID。在它的子进程调用了 `exec` 后，它就不再更改该子进程的进程组 ID。
    - 在大多数作业控制 `shell` 中，在 `fork` 之后调用此函数，使父进程设置其子进程的进程组 ID，并且也使子进程设置其自己的进程组 ID。
        - 这两个调用中有一个是冗余的。
        - 但让父进程和子进程都这样做可以保证，在父进程和子进程认为子进程已进入了该进程组之前，这确实已经发生了。
        - 如果不这样做，在 `fork` 之后，由于父进程和子进程运行的先后次序不确定，会因为子进程的组员身份取决于哪个进程首先执行而产生竞争条件。

## 5 会话
- 会话（`session`）是一个或多个进程组的集合。
- 通常是由 `shell` 的管道将几个进程编成一组的。
- 进程调用 `setsid` 函数建立一个新会话:

    ```cpp
    #include <unistd.h>
    pid_t setsid(void);
    // 返回值：若成功，返回进程组 ID；若出错，返回 -1
    ```
    - 如果调用此函数的进程不是一个进程组的组长，则此函数创建一个新会话。具体会发生以下 3 件事：
        - 该进程变成新会话的会话首进程（`session leader`，会话首进程是创建该会话的进程）。此时，该进程是新会话中的唯一进程。
        - 该进程成为一个新进程组的组长进程。新进程组 ID 是该调用进程的进程 ID。
        - 该进程没有控制终端。如果在调用 `setsid` 之前该进程有一个控制终端，那么这种联系也被切断。
    - 如果该调用进程已经是一个进程组的组长，则此函数返回出错。
        - 为了保证不处于这种情况，通常先调用 `fork`，然后使其父进程终止，而子进程则继续。因为子进程继承了父进程的进程组 ID，而其进程 ID 则是新分配的，两者不可能相等，这就保证了子进程不是一个进程组的组长。
    - 会话首进程是具有唯一进程 ID 的单个进程，所以可以将会话首进程的进程 ID 视为会话 ID。

- `getsid` 函数返回会话首进程的进程组 ID：

    ```cpp
    #include <unistd.h>
    pid_t getsid(pid_t pid);
    // 返回值：若成功，返回会话首进程的进程组 ID；若出错，返回 -1
    ```
    - 如若 `pid` 是 0，`getsid` 返回调用进程的会话首进程的进程组 ID。
    - 出于安全方面的考虑，一些实现下如若 `pid` 并不属于调用者所在的会话，那么调用进程就不能得到该会话首进程的进程组 ID。

## 6 控制终端
- 一个会话可以有一个控制终端。这通常是终端设备（在终端登录情况下）或伪终端设备（在网络登录情况下）。
- 建立与控制终端连接的会话首进程被称为控制进程。
- 一个会话中的几个进程组可被分成`一个`前台进程组以及一个或多个后台进程组。
- 如果一个会话有一个控制终端，则它有一个前台进程组，其他进程组为后台进程组。
- 无论何时键入终端的中断键（Delete 或 Ctrl+C），都会将中断信号发送至前台进程组的所有进程。
- 无论何时键入终端的退出键（Ctrl+\），都会将退出信号发送至前台进程组的所有进程。
- 如果终端接口检测到调制解调器（或网络）已经断开连接，则将挂断信号发送至控制进程（会话首进程）。
- 保证程序能与控制终端对话的方法是 open 文件 /dev/tty。在内核中，此特殊文件是控制终端的同义语。如果程序没有控制终端，则对于此设备的 open 将失败。

## 7 函数 `tcgetpgrp`、`tcsetpgrp` 和 `tcgetsid`
```cpp
#include <unistd.h>

pid_t tcgetpgrp(int fd);
// 返回值：若成功，返回前台进程组 ID；若出错，返回 -1

int tcsetpgrp(int fd, pid_t pgrpid);
// 返回值：若成功，返回 0；若出错，返回 -1

pid_t tcgetsid(int fd);
// 返回值：若成功，返回会话首进程的进程组 ID；若出错，返回 -1
```
- 函数 `tcgetpgrp` 返回前台进程组 ID，它与在 fd 上打开的终端相关联。
- 如果进程有一个控制终端，则该进程可以调用 `tcsetpgrp` 将前台进程组 ID 设置为 `pgrpid`。`pgrpid` 值应当是在同一会话中的一个进程组 ID。fd 必须引用该会话的控制终端。
- 给出控制终端的文件描述符，通过 `tcgetsid` 函数，应用程序就能获得会话首进程的进程组 ID。

## 8 作业控制
- 作业控制允许在一个终端上启动多个作业（进程组），它控制哪一个作业可以访问该终端以及哪些作业在后台运行。
- 从 `shell` 使用作业控制功能的角度观察，用户可以在前台或后台启动一个作业。一个作业只是几个进程的集合，通常是一个进程管道。
- 当启动一个后台作业时，`shell` 赋予它一个作业标识符，并打印一个或多个进程 ID。
- 如果后台作业试图读终端，这并不是一个错误，但是终端驱动程序将检测这种情况，并且向后台作业发送一个特定信号 `SIGTTIN`。该信号通常会停止此后台作业，而 `shell` 则向有关用户发出这种情况的通知，然后用户就可用 `shell` 命令将此作业转为前台作业运行，于是它就可读终端。
- 后台作业输出到控制终端是一个可以允许或禁止的选项。通常，可以用 `stty` 命令改变这一选项。
- fg 命令将此作业转为前台作业运行, 并将继续信号 (`SIGCONT`) 送给该进程组。

```sh
$ cat > temp.foo &          # 在后台启动，但从标准输入读
[1]     1681                # shell打印作业号(1)和进程ID (1681)
$                           # 键入回车
[1] + Stopped (SIGTTIN)     cat > temp.foo
$ fg %1                     # 使1号作业成为前台作业
cat > temp.foo              # shell告诉我们现在哪一个作业在前台
hello world                 # 输入一行
^D                          # 键入文件结束符
$ cat temp.foo              # 检查该行已送入文件
hello world
```

```sh
$ cat temp.foo &                        # 在后台执行
[1]     1719
$ hello world                           # 提示符后出现后台作业的输出
                                        # 键入回车
[1] + Done  cat temp.foo
$ stty tostop                           # 禁止后台作业输出到控制终端
$ cat temp.foo &                        # 在后台再试一次
[1]     1721
$                                       # 键入回车 ，发现作业已停止
[1] + Stopped(SIGTTOU) cat temp.foo
$ fg %1                                 # 使1号作业成为前台作业
cat temp.foo                            # shell告诉我们现在哪一个作业在前台
hello world                             # 这是该作业的输出
```
<img src=img/作业控制.png width=40% />

## 9 孤儿进程组
- `POSIX.1` 将孤儿进程组定义为：该组中每个成员的父进程要么是该组的一个成员，要么不是该组所属会话的成员。
- 对孤儿进程组的另一种描述可以是：一个进程组不是孤儿进程组的条件是——该组中有一个进程，其父进程在属于同一会话的另一个组中。如果进程组不是孤儿进程组，那么在属于同一会话的另一个组中的父进程就有机会重新启动该组中停止的进程。
- 当孤儿进程组产生时，`POSIX.1` 要求向新孤儿进程组中处于停止状态的每一个进程发送挂断信号（`SIGHUP`），接着又向其发送继续信号（`SIGCONT`）。

## 10 `shell` 控制符

- 控制字符都是可以通过 `stty` 命令更改的，可在终端中输入命令 `"stty -a"` 查看终端配置。

| 控制符     | 功能                                                         |
| ---------- | ------------------------------------------------------------ |
| `ctrl + z` | 发送 `SIGTSTP`（20号信号）给前台进程组中的所有进程，用于挂起一个进程，而不是结束进程。 |
| `ctrl + c` | 当在 `shell` 中按下 `ctrl+c` 时，会发送 `SIGINT`（2号信号）给前台进程组中的所有进程，强制终止程序的执行。 |
| `ctrl + h` | 显示隐藏的目录。                                             |
| `ctrl + d` | 一个特殊的二进制值，表示 `EOF`，作用相当于在终端中输入 `exit` 后回车。 |
| `ctrl + \` | 发送 `SIGQUIT`（3号信号）给前台进程组中的所有进程，终止前台进程并生成 `core` 文件。 |
| `ctrl + s` | 中断控制台输出。                                             |
| `ctrl + q` | 恢复控制台输出。                                             |
| `ctrl + l` | 清屏。                                                       |

