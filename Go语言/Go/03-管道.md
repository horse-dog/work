## chan

```go
type hchan struct {
	qcount   uint           // total data in the queue
	dataqsiz uint           // size of the circular queue
	buf      unsafe.Pointer // points to an array of dataqsiz elements
	elemsize uint16
	closed   uint32
	elemtype *_type // element type
	sendx    uint   // send index
	recvx    uint   // receive index
	recvq    waitq  // list of recv waiters
	sendq    waitq  // list of send waiters
	lock mutex
}

type waitq struct {
    first *sudog
    last  *sudog
}

type sudog struct {
    g *g

    next *sudog
    prev *sudog
    elem unsafe.Pointer // data element (may point to stack)
    // ...
    c        *hchan 
}
```

- qcount: 当前 channel 中存在多少个元素

- dataqsize: 当前 channel 能存放的元素容量

- buf: channel 中用于存放元素的环形缓冲区

- elemsize: channel 元素类型的大小

- closed: 标识 channel 是否关闭

- elemtype: channel 元素类型

- sendx: 发送元素进入环形缓冲区的 index

- recvx: 接收元素所处的环形缓冲区的 index

- recvq: 因接收而陷入阻塞的协程队列

- sendq: 因发送而陷入阻塞的协程队列


## 构造器函数

```go
func makechan(t *chantype, size int) *hchan {
    elem := t.elem

    // ...
    mem, overflow := math.MulUintptr(elem.size, uintptr(size))
    if overflow || mem > maxAlloc-hchanSize || size < 0 {
        panic(plainError("makechan: size out of range"))
    }

    var c *hchan
    switch {
    case mem == 0:
        // Queue or element size is zero.
        c = (*hchan)(mallocgc(hchanSize, nil, true))
    case elem.ptrdata == 0:
        // Elements do not contain pointers.
        // Allocate hchan and buf in one call.
        c = (*hchan)(mallocgc(hchanSize+mem, nil, true))
        c.buf = add(unsafe.Pointer(c), hchanSize)
    default:
        // Elements contain pointers.
        c = new(hchan)
        c.buf = mallocgc(mem, elem, true)
    }

    c.elemsize = uint16(elem.size)
    c.elemtype = elem
    c.dataqsiz = uint(size)
    
    lockInit(&c.lock, lockRankHchan)

    return
}
```

- 判断申请内存空间大小是否越界，mem 大小为 element 类型大小与 element 个数相乘后得到，仅当无缓冲型 channel 时，因个数为 0 导致大小为 0

- 根据类型，初始 channel，分为 无缓冲型、有缓冲元素为 struct 型、有缓冲元素为 pointer 型 channel

- 倘若为无缓冲型，则仅申请一个大小为默认值 96 的空间

- 如若有缓冲的 struct 型，则一次性分配好 96 + mem 大小的空间，并且调整 chan 的 buf 指向 mem 的起始位置

- 倘若为有缓冲的 pointer 型，则分别申请 chan 和 buf 的空间，两者无需连续

- 对 channel 的其余字段进行初始化，包括元素类型大小、元素类型、容量以及锁的初始化

## 写流程

```go
func chansend1(c *hchan, elem unsafe.Pointer) {
    chansend(c, elem, true, getcallerpc())
}


func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool {
    if c == nil {
        gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2)
        throw("unreachable")
    }


    lock(&c.lock)


    if c.closed != 0 {
        unlock(&c.lock)
        panic(plainError("send on closed channel"))
    }

	if sg := c.recvq.dequeue(); sg != nil {
		// Found a waiting receiver. We pass the value we want to send
		// directly to the receiver, bypassing the channel buffer (if any).
		send(c, sg, ep, func() { unlock(&c.lock) }, 3)
		return true
    }

	if c.qcount < c.dataqsiz {
        // Space is available in the channel buffer. Enqueue the element to send.
        qp := chanbuf(c, c.sendx)
        typedmemmove(c.elemtype, qp, ep)
        c.sendx++
        if c.sendx == c.dataqsiz {
            c.sendx = 0
        }
        c.qcount++
        unlock(&c.lock)
        return true
    }

	gp := getg()
    mysg := acquireSudog()
    mysg.elem = ep
    mysg.g = gp
    mysg.c = c
    gp.waiting = mysg
    c.sendq.enqueue(mysg)
    
    atomic.Store8(&gp.parkingOnChan, 1)
    gopark(chanparkcommit, unsafe.Pointer(&c.lock), waitReasonChanSend, traceEvGoBlockSend, 2)
    
    gp.waiting = nil
    closed := !mysg.success
    gp.param = nil
    mysg.c = nil
    releaseSudog(mysg)
    return true
}
```

- 对于未初始化的 chan，写入操作会引发死锁

- 对于已关闭的 chan，写入操作会引发 panic

- 写时存在阻塞读协程: 取出一个读队列的sudog，memmove拷贝元素到sudog对应的goroutine

- 写时无阻塞读协程但环形缓冲区仍有空间: 将当前元素添加到环形缓冲区 sendx 对应的位置, sendx++, qcount++

- 写时无阻塞读协程且环形缓冲区无空间: 构造 sudog, 建立 sudog、goroutine、channel 之间的指向关系, 把 sudog 添加到当前 channel 的阻塞写协程队列中, park 当前协程, 倘若协程从 park 中被唤醒，则回收 sudog（sudog能被唤醒，其对应的元素必然已经被读协程取走）

## 读流程

```go
func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) {
    if c == nil {
        gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2)
        throw("unreachable")
    }
    
	lock(&c.lock)

    if c.closed != 0 {
        if c.qcount == 0 {
            unlock(&c.lock)
            if ep != nil {
                typedmemclr(c.elemtype, ep)
            }
            return true, false
        }
        // The channel has been closed, but the channel's buffer have data.
    }

    // Just found waiting sender with not closed.
    if sg := c.sendq.dequeue(); sg != nil {
        recv(c, sg, ep, func() { unlock(&c.lock) }, 3)
        return true, true
	}

	if c.qcount > 0 {
        // Receive directly from queue
        qp := chanbuf(c, c.recvx)
        if ep != nil {
            typedmemmove(c.elemtype, ep, qp)
        }
        typedmemclr(c.elemtype, qp)
        c.recvx++
        if c.recvx == c.dataqsiz {
            c.recvx = 0
        }
        c.qcount--
        unlock(&c.lock)
        return true, true
    }

    gp := getg()
    mysg := acquireSudog()
    mysg.elem = ep
    gp.waiting = mysg
    mysg.g = gp
    mysg.c = c
    gp.param = nil
    c.recvq.enqueue(mysg)
    atomic.Store8(&gp.parkingOnChan, 1)
    gopark(chanparkcommit, unsafe.Pointer(&c.lock), waitReasonChanReceive, traceEvGoBlockRecv, 2)

    gp.waiting = nil
    success := mysg.success
    gp.param = nil
    mysg.c = nil
    releaseSudog(mysg)
    return true, success
}
```

- 对于未初始化的 chan，读操作会引发死锁

- 对于已关闭的 chan, 且 chan 内部无元素, 直接解锁返回即可

- 读时有阻塞的写协程: 从写队列中获取一个协程, 倘若 channel 无缓冲区，则直接读取写协程元素，并唤醒写协程, 倘若 channel 有缓冲区，则读取缓冲区头部元素，并将写协程元素写入缓冲区尾部后唤醒写协程

- 读时无阻塞写协程且缓冲区有元素: 获取到 recvx 对应位置的元素, recvx++, qcount--

- 读时无阻塞写协程且缓冲区无元素: 构造 sudog, 建立 sudog、goroutine、channel 之间的指向关系, 把 sudog 添加到当前 channel 的阻塞读协程队列中, park 当前协程, 倘若协程从 park 中被唤醒，则回收 sudog（sudog能被唤醒，其对应的元素必然已经被写入）


## 阻塞与非阻塞模式

- 非阻塞模式下，读/写 channel 方法通过一个 bool 型的响应参数，用以标识是否读取/写入成功.

- 所有需要使得当前 goroutine 被挂起的操作，在非阻塞模式下都会返回 false

- 所有使得当前 goroutine 会进入死锁的操作，在非阻塞模式下都会返回 false

- 所有能立即完成读取/写入操作的条件下，非阻塞模式下会返回 true

- 默认情况下，读/写 channel 都是阻塞模式，只有在 select 语句组成的多路复用分支中，与 channel 的交互会变成非阻塞模式

- 在 select 语句包裹的多路复用分支中，读和写 channel 操作会被汇编为 selectnbrecv 和 selectnbsend 方法，底层同样复用 chanrecv 和 chansend 方法，但此时由于第三个入参 block 被设置为 false，导致后续会走进非阻塞的处理分支.

```go
func selectnbsend(c *hchan, elem unsafe.Pointer) (selected bool) {
	return chansend(c, elem, false, getcallerpc())
}

func selectnbrecv(elem unsafe.Pointer, c *hchan) (selected, received bool) {
	return chanrecv(c, elem, false)
}
```


## 两种读 channel 的协议

- 读取 channel 时，可以根据第二个 bool 型的返回值用以判断当前 channel 是否已处于关闭状态

```go
ch := make(chan int, 2)
got1 := <- ch
got2,ok := <- ch
```

- 实现上述功能的原因是，两种格式下，读 channel 操作会被编译成不同的方法

```go
func chanrecv1(c *hchan, elem unsafe.Pointer) {
    chanrecv(c, elem, true)
}

//go:nosplit
func chanrecv2(c *hchan, elem unsafe.Pointer) (received bool) {
    _, received = chanrecv(c, elem, true)
    return
}
```


## readonly/writeonly chan

- readonly: <-chan int

- writeonly: chan<- int


## 关闭

```go
func closechan(c *hchan) {
    if c == nil {
        panic(plainError("close of nil channel"))
    }

    lock(&c.lock)
    if c.closed != 0 {
        unlock(&c.lock)
        panic(plainError("close of closed channel"))
    }

    c.closed = 1

    var glist gList
    // release all readers
    for {
        sg := c.recvq.dequeue()
        if sg == nil {
            break
        }
        if sg.elem != nil {
            typedmemclr(c.elemtype, sg.elem)
            sg.elem = nil
        }
        gp := sg.g
        gp.param = unsafe.Pointer(sg)
        sg.success = false
        glist.push(gp)
    }

    // release all writers (they will panic)
    for {
        sg := c.sendq.dequeue()
        if sg == nil {
            break
        }
        sg.elem = nil
        gp := sg.g
        gp.param = unsafe.Pointer(sg)
        sg.success = false
        glist.push(gp)
    }
    unlock(&c.lock)

    // Ready all Gs now that we've dropped the channel lock.
    for !glist.empty() {
        gp := glist.pop()
        gp.schedlink = 0
        goready(gp, 3)
  }
}
```

- (1) 关闭未初始化过的 channel 会 panic

- (2) 加锁

- (3) 重复关闭 channel 会 panic

- (4) 将阻塞读协程队列中的协程节点统一添加到 glist

- (5) 将阻塞写协程队列中的协程节点统一添加到 glist 

- (6) 唤醒 glist 当中的所有协程 (写协程会panic)
