#### 操作系统的发展历程

- 手工操作阶段

- 批处理阶段：在纸袋输入和计算机处理直接添加了一个缓冲：磁带

  - 单道批处理系统：不具并发能力

  - 多道批处理系统：具有并发能力

- 分时操作系统：具备了用户交互能力，计算机以时间片为单位轮流为各个用户/作业服务。作业没有优先级区分。

- 实时操作系统：作业具备优先级。

- 网络操作系统、分布式操作系统、个人计算机操作系统等其他系统

#### 操作系统运行机制和体系结构

- 指令的区分：特权指令（例如内存清零指令）和非特权指令（例如各种运算指令）

- 处理器状态：用户态和内核态，用户态只能执行非特权指令，内核态可以执行两种指令。

- 程序状态字寄存器：

  - IF标志：中断标志，为1允许中断，当前处于用户态，为0禁止中断，当前处于内核态

  - IOPL标志：标记当前代码所在的特权级别，为0时表示当前处于内核态，否则当前处于用户态。

  - 其他标志：CF、SF、ZF、OF 等。

- 内核程序和应用程序

- 内核功能：时钟管理、中断处理、原语（具有原子性）、进程管理、存储管理、设备管理等

- 宏内核和微内核：宏内核性能高，但代码复杂混乱。微内核性能低，但代码结构清晰，方便维护。

#### 中断和异常

- 内中断：cpu内部代码导致的中断，例如进行系统调用。内中断又称异常。

  - 故障：缺页异常，非法操作码，整数除0，运算溢出等
  
  - 陷入：进行系统调用

  - 终止：出现了CPU无法继续执行的硬件故障

- 外中断：cpu外部设备导致的中断，例如时钟中断，IO中断等。

  - 可屏蔽中断：INTR

  - 不可屏蔽中断：NMI：紧急事件，一般是严重的硬件故障或断电等。

- 中断使CPU从用户态切换为内核态。并且中断是这种切换的唯一途径。

- 外中断等处理过程：每条指令执行结束后，CPU例行检查是否有外部中断信号，如果有，则保存当前上下文，转入对应的中断处理程序，中断处理程序完成后恢复之前的上下文并继续执行原进程。

#### 系统调用

- 凡是与资源有关的操作，都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。

- 系统调用（按功能分类）

  - 设备管理：完成设备的 请求/释放/启动 等功能

  - 文件管理：完成文件的 读/写/创建/删除 等功能

  - 进程控制：完成进程的 创建/撤销/阻塞/唤醒 等功能

  - 进程通信：完成进程之间的 消息传递/信号传递 等功能

  - 内存管理：完成内存的 分配/回收 等功能

- 系统调用和库函数的区别：

  - 系统调用时操作系统向上层提供的接口。

  - 部分库函数底层会使用系统调用。

  - 应用程序可以直接使用系统调用，也可以通过库函数间接使用系统调用。

- 陷入指令：需要进行系统调用时，在用户态执行，使得CPU进入内核态，然后执行相应的系统调用。

- 陷入指令的汇编格式：int x。其中 x 为系统调用码。

- 陷入指令是唯一一个只能在用户态执行，而不可在内核态执行的指令。

#### 进程管理

##### 进程

- 进程是系统进行资源分配的基本单位。

- 进程控制块：存储进程的控制信息。

- 进程的状态：创建、销毁、运行、阻塞、就绪。

- 原语的实现方式：在想要实现的原子操作的指令序列前后分别插入关中断指令和开中断指令。关中断指令屏蔽中断，开中断指令允许中断。在关中断和开中断之间到达的中断信号将被阻塞直至开中断。但是如果中断信号是NMI不可屏蔽中断，则无视关中断指令，立即执行中断处理程序，因为NMI是紧急事件，需要即时处理。

- 关中断指令和开中断指令是针对外中断而言的，无法屏蔽内中断。

- 进程控制原语：

  - 创建原语：创建进程

  - 撤销原语：销毁进程
  
  - 阻塞原语：将进程由运行态转换为阻塞态
  
  - 唤醒原语：将进程由阻塞态转换为就绪态
  
  - 切换原语：将进程由运行态转换为就绪态

##### 进程通信

- 管道 pipe：历史上，管道是半双工的，现在某些实现提供全双工管道，但为了最佳可移植性，应假设管道是半双工的。

  ```cpp
  #include <unistd.h>
  #include <iostream>
  using namespace std;
  
  const size_t BufferSize = 1024;
  
  int main(int argc, const char *argv[]) {
    pid_t pid {};
    int fd[2] {};
    char buffer[BufferSize] {};
    pipe(fd);
    if ((pid = fork()) < 0) return 1;
    if (pid > 0) {
      close(fd[0]);
      write(fd[1], "hello world!\n", 12);
    } else {
      close(fd[1]);
      n = read(fd[0], buffer, BufferSize);
      write(STDOUT_FILENO, buffer, n);
    }
    return 0;
  }
  ```

- 命名管道（FIFO）

- 共享内存：需要保证读写安全

- 消息队列：发送消息/接收消息原语。消息头(发送进程ID，接收进程ID，消息类型等)+消息体

  - 直接通信方式：消息直接挂到接收进程到消息缓冲队列上。

  - 间接通信方式：消息发送到中间实体（信箱）中。类似于计网中的邮件系统。

##### 进程与线程

- 进程作为资源分配的基本单位

- 线程作为cpu调度的基本单位

- 同一进程内的线程的切换开销小于进程切换

- 线程使用TID标识，控制结构为TCB

- 线程也具有就绪、阻塞、运行三种基本状态

- 线程的实现方式：

  - 用户级线程：不需要切换到内核态来进行线程切换

  - 系统级线程：操作系统实际调度的线程，需要在内核态进行切换

##### 多线程模型：

  -   一对一模型：一个进程启动了多个用户线程，这些用户线程每一个都对应了一个系统级线程

    - 优点：并发程度高，例如一个进程包含多个线程，其中某一个线程阻塞，对其他线程没有影响。

    - 缺点：切换开销大，用户级线程切换一定对应了一次系统级线程的切换。

    - 举例：pthread，c++11 thread，java thread

  - 多对一模型：一个进程启动了多个用户线程，这些用户线程底层都和一个系统线程绑定

    - 优点：切换开销小，一个进程里的不同用户线程间的切换并不需要切换到内核态

    - 缺点：并发程度低，例如一个进程包含多个线程，其中某一个线程阻塞，则这个进程的其他线程无法被调度。

    - 举例：jdk1.2 之前的多线程库

  - 多对多模型：一个进程启动了多个用户线程，这些用户线程底层和多个系统线程绑定

    - 是一对一模型和一对多模型的折中，优缺点也是折中的。

    - 举例：goroutine 的实现方式

##### 进程调度

- 作业调度（高级调度）：按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程。发生频率低。

- 内存调度（中级调度）：按照某种规则，从挂起队列中选择合适的进程将其数据调回内存。发生频率中等。

- 进程调度（低级调度）：按照某种规则，从就绪队列中选择一个进程为其分配处理机。发生频率最高。

##### 不能进行进程调度的情形

- 在处理中断的过程中

- 进程在**操作系统内核**程序临界区中

- 原子操作过程中（原语）

##### 调度算法评价指标

- CPU利用率：CPU忙碌时间与总时间之比

- 系统吞吐量：单位时间完成作业数量

- 周转时间：提交作业到完成作业的耗时。周转时间 = 等待时间 + 实际运行时间 + IO操作时间。

- 带权周转时间：作业周转时间/作业实际运行时间

- 等待时间：等待被服务的时间

- 响应时间：从用户提交请求到首次产生响应所用的时间

##### 调度算法：FCFS、SJF、HRRN算法（适合早期的批处理系统）

- FCFS（First Come First Serve）：先来先服务。非抢占式。

  - 优点：公平，简单。

  - 缺点：对长作业有利，对短作业不利。

  - 不会导致饥饿。

- SJF（Shortest Job First）：短作业优先。分为抢占式短作业优先和非抢占式短作业优先。

  - 优点：平均等待时间，平均周转时间较短。

  - 缺点：对短作业有利，对长作业不利。有可能导致长作业饥饿。

  - 非抢占式短作业优先：选择当前就绪的需要运行的时间最短的作业运行。

  - 抢占式短作业优先：每当有新的作业就绪时，刷新所有作业的剩余的需要运行的时间，选择最短的作业运行。

  - 作业需要运行的时间由作用户提供，并不一定是真实的。

  - 会导致饥饿。

- HRRN（Highest Responce Ratio Next）：高响应比优先。非抢占式。选择响应比最高的作业运行。

  - 响应比 = （已等待时间 + 要求服务时间）/（要求服务时间）

  - 不会导致饥饿。

##### 调度算法：时间片轮转算法、优先级调度算法、多级反馈队列算法（适合交互式系统）

- 时间片轮转算法：用于进程调度，抢占式，通过时钟中断剥夺CPU。

  - 时间片太大，退化为FCFS，时间片太小，切换开销太大。

  - 优点：公平，响应快，适合分时操作系统。

  - 缺点：高频的进程切换有开销，无法区分进程优先级。

  - 不会导致饥饿。

- 优先级调度算法：既有抢占式，也有非抢占式。

  - 系统进程优先级高于用户进程。

  - 前台进程优先级高于后台进程。

  - I/O繁忙型进程优先级高于CPU繁忙型进程。

  - 可以区分进程优先级。但可能导致饥饿。

- 多级反馈队列调度算法：抢占式算法。用于进程调度。

  - 多级就绪队列，级别越低的就绪队列进程可以获取的CPU时间片越短，进程优先级越高。

  - 进程时间片结束，若进程仍未结束，入队到下一级就绪队列。

  - 进程时间片未结束，但到达了更高优先级的进程，此时抢占CPU，当前进程入队原来的就绪队列。

  - 可能会导致饥饿：例如不断有新进程到来，此时高级别的就绪队列中的进程会产生饥饿。

- CFS调度策略（Completely Fair Scheduler）：Linux系统默认的进程调度策略。

  - 虚拟运行时间：进程在CPU上实际运行的时间除以进程权重。进程优先级越高，则进程的权重越高。

  - 内核维护一颗红黑树，按虚拟运行时间排序，每次选择虚拟运行时间最小的节点的进程分配给CPU运行。

  - 权重越高的进程将获得更多的CPU时间片。

##### 进程的同步和互斥

- 软件实现：Peterson算法实现进程互斥

  ```cpp
  // 使用C语言逻辑描述的Peterson算法
  
  bool flag[2] {};
  int  turn = 0;
  
  // P0 进程
  flag[0] = true;	// 需要保证原子操作：P0进程想要进入临界区
  turn = 1;				// 需要保证原子操作：P0进程可以优先让P1进程进入临界区
  while (flag[1] && turn == 1); // 需要保证原子操作：如果P1想要进入临界区并且最近一次是自己“让梨”，自旋阻塞
  // cirtical section;
  flag[0] = false;
  // remainder section;
  
  // P1 进程
  flag[1] = true;	// 需要保证原子操作：P1进程想要进入临界区
  turn = 0;				// 需要保证原子操作：P1进程可以优先让P0进程进入临界区
  while (flag[0] && turn == 0);	// 需要保证原子操作：如果P0想要进入临界区并且最近一次是自己“让梨”，自旋阻塞
  // cirtical section;
  flag[1] = false;
  // remainder section;
  ```

- 硬件实现：

  - 中断屏蔽方法：关中断 -> 临界区 -> 开中断。

    缺点：但仅适合单处理机。关中断需要在内核态，所以仅适用于内核。

  - TSL指令：原子操作

    ```cpp
    // c语言描述的逻辑，实际为原子操作
    bool testAndSet(bool *locker) {
      bool old = *locker;
      *locker  = true;
      return old;
    }
    
    // 使用：
    while (testAndSet(&locker));
    // cirtical section...
    locker = false;
    // remainder section...
    ```

    缺点：自旋锁，比较适用于内核。

  - XCHG指令：原子操作

    ```cpp
    // c语言描述的逻辑，实际为原子操作
    void swap(bool* a, bool* b) {
      bool tmp = *a;
      *a = *b;
      *b = tmp;
    }
    
    // 使用：
    bool old = true;
    while (old = true)
      swap(&locker, &old);
    // cirtical section...
    locker = false;
    // remainder section...
    ```

    缺点：自旋锁，比较适用于内核。

##### 信号量

```cpp
// cpp 实现线程间信号量
class sem_t {
 private:
  int count;									/*> resource count */
	std::mutex mtx;							/*> mutex */
  std::condition_variable cv;	/*> cond */
 public:
	sem_t(int num) : count(num), mtx(), cv() {};
  sem_t(sem_t&&) = default;
  void wait() {
    std::unique_lock<std::mutex> locker(mtx);
    cv.wait(locker, [this] { return this->count > 0; });
    --count;
  }
  void signal() {
    mtx.lock();
    ++count;
    mtx.unlock();
    cv.notify_one();
  }
}

// wait
auto P = std::mem_fn(&sem_t::wait);

// signal
auto V = std::mem_fn(&sem_t::signal);
```

##### 进程同步经典问题

- 生产者消费者问题

- 多生产者多消费者问题：吃苹果和橘子问题

- 吸烟者问题

- 读者写者问题

- 哲学家进餐问题

##### 管程

- 管理一组临界资源，对这些资源的访问使用管程提供的API。

- 每次仅允许一个进程在管程内执行某一个API。

- 管程封装后，简化了代码实现复杂度。

```java
// 管程解决生产者消费者问题
monitor ProducerConsumer {
  conditon full, empty;
  int count = 0;
  void insert(Item item) {
    if (count == N) wait(full);
    count++;
    insert_item(item);
    if (count == 1) signal(empty);
  }
  
  Item remove() {
    if (count == 0) wait(empty);
    count--;
    if (count == N-1) signal(full);
    return remove_item();
  }
}

producer() {
  while(1) {
    item = 生产一个产品;
    ProducerConsumer.insert(item);
  }
}

consumer() {
  while(1) {
    item = ProducerConsumer.remove();
    消费产品item;
  }
}
```

##### 死锁

- 死锁产生的必要条件：

  - 互斥条件：对临界资源进行竞争

  - 不剥夺条件：进程获取的临界资源不能由其他进程强行夺走，只能主动释放。

  - 请求和保持条件：进程已经至少占有一个临界资源，又提出了新的资源请求。

  - 循环等待条件：存在临界资源等待环。

- 预防死锁：破坏死锁产生的必要条件之一。

  - 互斥条件：小部分临界资源逻辑上可以转换为共享资源。例如 SPOOLing 技术。

  - 不剥夺条件：资源可被其他进程剥夺。但实现复杂。例如 CPU 上下文切换。

  - 请求和保持条件：需要的资源一次性申请。缺点是降低了并发度。

  - 循环等待条件：通过一定策略避免成环。实现复杂。

- 避免死锁：银行家算法。确保资源分配后仍然存在安全序列。

- 死锁的检测和解除：资源分配图，可完全简化则没有死锁。否则剥夺部分资源或撤销死锁进程或回退。

#### 存储管理

##### 链接

- 静态链接：各目标及模块链接成一个完整的可执行文件。

  例如：gcc -static，.a 文件链接。

- 装入时动态链接：各目标模块装入内存时，边装入边链接的方式。

  例如：gcc -shared 生成 .so 文件。

- 运行时动态链接：在程序执行时，需要该模块时才会对其进行链接。

  例如：gcc -shared -fPIC 生成 .so 文件。使用时，使用 dlopen, dlsym, dlclose来加载动态库，调用函数，关闭动态库。
  
  在链接时要加上参数 -ldl（指定dl库）。-fPIC指明生成与位置无关的代码，即机器码中不包含绝对地址。

- 如果同时存在同名的静态库和动态库,在编译时,会优先选择动态库,如果执意选择静态库,则需要在编译的时候添加 -static选项。

- PATH、 LIBRARY_PATH、 LD_LIBRARY_PATH

  - PATH 保存可执行文件程序路径。

  - LIBRARY_PATH 是在程序编译期间查找动态链接库时指定的查找共享库的路径。

  - LD_LIBRARY_PATH环境变量主要是用于指定动态链接器（ld）查找ELF可执行文件运行时所依赖的动态库（so）的路径。

##### 装入

- 绝对装入：编译时将逻辑地址加上偏移量直接得到物理地址。只适用于单道程序环境。

- 静态重定位：装入时将逻辑地址加上偏移量转换为物理地址。

- 动态重定位：运行时将逻辑地址加上重定位寄存器中的值得到实际物理地址。现代操作系统使用的方式。

##### 动态分区分配算法

- 首次适应算法

- 最佳适应算法

- 最坏适应算法

- 邻近适应算法

##### 分页存储管理

- 逻辑地址 = 逻辑页号 | 页内偏移

- 操作系统为每个进程维护一张页表，页表始址存储在PCB中，页表实现逻辑页号到物理页号到转换

- 页表项至少包括：该页面所在的内存块号。

- 页面大小通常为4KB

- 页表寄存器(CR3寄存器)：当进程上CPU运行时，存放该进程的页表起始地址和页表长度

- 快表：高速缓存，存储经常访问的页表项

##### 多级页表

- 维护树状页表索引

- 两级页表：一级页表号 | 二级页表号 | 页内偏移

- 需要注意，例如如果页面大小为4KB，逻辑地址为40位，一个页表项大小为4B

  - 由于页面大小为4KB = 2^12B，所以页内偏移为12位，页号为 40 - 12 = 28位

  - 由于页表项大小为4B，所以一个页面只能存储 4KB / 4B = 1K = 2^10 个页表项。所以每级页表的页表号最长为10

  - 因此，上述问题中，必须有三级页表。

- 多级页表的访存次数：假设没有快表机构，N级页表访问一个逻辑地址需要N+1次访存。

##### 基本分段存储管理方式

- 段表索引与页表索引类似，逻辑地址由 段号 + 段内偏移组成。与页表不同，每个段表项还需要记录该段的长度。

- 基本分段存储管理方式中，每个进程维护一张段表，段表始址存储在PCB中，进程运行时，段表寄存器存放段表始址和段表长度。

- 段表项至少包括：该段的段长，该段在内存中的起始地址。

- 分段管理中，进行内存映射时，需要检查查询的段号是否越界，还需要查询段内偏移是否超过该段的段长。

- 分段管理将程序在逻辑上进行划分，更容易实现信息的共享和保护，有助于跨进程的内存共享。例如不能被修改的代码（即纯代码或可重入代码）就可以被多个进程共享。

- 分段管理中也可以有快表机制。

##### 段页式存储管理方式

- 分页管理内存空间利用率高，不会产生外部碎片，只会有少量内部碎片。但不利于共享和保护。

- 分段管理方便逻辑模块的信息共享和保护。但是会产生外部碎片。

- 段页式管理是一种折中方案。逻辑地址组成为：段号 ｜ 页号 ｜ 页内偏移。

- 段表项至少包括：该段含有的页面数量，该段的页表所在的块号。

- 页表项至少包括：该页面所在的块号。

- 段页式管理中的快表机制的key为：段号+页号。

##### 虚拟内存技术

- 虚拟内存技术使用局部性原理，将暂时不用的页面挂起到外存，使得虚拟内存的容量可以大于内存的大小。

- 虚拟内存技术建立在离散存储管理方式上，基本分段，基本分页，基本段页式技术通过虚拟内存技术扩展为请求分段，请求分页，请求段页式技术。

##### 请求分页存储管理

- 页表机制：页表项组成：页面对应的内存块号，状态位（是否装入），访问字段（实现LRU或LFU），脏位（是否被修改过），外存地址（对应的外存块的地址）。

- 缺页中断机构：

  - 状态位如果为未装入，产生缺页中断，进入缺页中断处理程序。

  - 如果内存已满，需要采用页面置换算法将某个（些）页面淘汰到外存。

- 地址变换机构

  - 快表中的页面一定是在内存中的，若某个页面被换出外存，则快表中的相应表项也要删除，否则快表可能访问错误的页面。

  - 修改页面各个字段时，如果该页面的页表项在快表中存在，优先修改快表中的页表项，以减少访存次数，当该页表项需要从快表中被淘汰时，才将这些信息写入内存中的页表项。

##### 页面置换算法

- 最佳置换算法（OPT）：已知页面调度序列，页面替换时选择接下来最长时间不会被调度的页面进行替换。

  - 缺页率最小，性能最好

  - 无法实现

- 先进先出置换算法（FIFO）：优先淘汰最先进入内存的页面

  - 实现简单

  - 性能很差，可能出现 Belady 异常

- 最近最久未使用置换算法（LRU）：优先淘汰最近最久没访问的页面

  - 性能很好

  - 需要硬件支持，算法开销大

- 时钟置换算法（CLOCK）：循环扫描各页面，第一轮淘汰访问位=0的，并将扫描过的页面访问位改为1，若第一轮没选中，则进行第二轮扫描。

  - 实现简单，算法开销小

  - 未考虑页面是否被修改过。

- 改进型的时钟置换算法：（访问位，修改位）的形式表述。

  - 第一轮，淘汰 (0, 0)

  - 第二轮，淘汰 (0, 1)，并将扫描过的页面访问位都置为0

  - 第三轮，淘汰 (0, 0)

  - 第四轮，淘汰 (0, 1)


##### 驻留集

指请求分野存储管理中给进程分配的物理块的集合

##### 页面分配、置换策略

- 固定分配：每个进程的驻留集不可变

- 可变分配：每个进程的驻留集可拓展

- 局部置换：缺页时页面调度只发生在本进程的驻留集中。

- 全局置换：缺页时页面调度发生在整个物理内存中。

- 固定分配局部置换

- 可变分配全局置换

- 可变分配局部置换

##### 抖动/颠簸

页面频繁换入换出的现象。主要原因是分配给进程的物理块不够

##### 工作集

- 在某段时间间隔内，进程实际访问页面的集合。

- 驻留集大小一般不能小于工作集大小。
