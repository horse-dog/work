#### 虚拟内存

- 页表

- 多级页表

- 段页式存储管理方式

- 页表寄存器：CR3寄存器，存储当前进程正在使用的页表的物理地址

- 快表机构TLB

#### 共享内存

- 多个进程可以将虚拟地址映射到同一段物理地址，实现共享内存

#### 写时复制

- linux 中 fork 后采用写时复制技术

#### 调度策略

- 轮转调度

- 优先级调度（nice）

- 多级反馈队列调度算法

- 完全公平调度器CFS：优先调度虚拟运行时间（vruntime）最少的进程，如果不考虑进程优先级，虚拟运行时间等价于实际在cpu上的运行时间，为了在CFS的基础上支持优先级调度，linux采用了"虚拟运行时间"，即运行相同的cpu时间，对于优先级高的进程而言，其虚拟运行时间会小于优先级低的进程，这样就保证了虽然实际运行时间相同，但优先级高的进程被调度的概率更大。linux内核使用红黑树实现根据vruntime对进程统一管理。

- 实时调度：紧急任务必须保证在指定时间范围内完成。

#### 优先级反转

- 在实时操作系统中，考虑如下情形：

```c
void taskA() {  // 低优先级任务
    mutex_lock(&lock);
    // do something...
    mutex_unlock(&lock);
}

void taskB() {  // 中优先级任务
    while (1);
}

void taskC() {  // 高优先级任务
    sleep(1);
    mutex_lock(&lock);
    // do something...
    mutex_unlock(&lock);
}
```

- 首先调度C，C睡眠，调度B，然后调度A，A获得锁，A还没有释放锁时C睡眠结束，调度C，但是C上锁失败，而B优先级高，B获得大量CPU时间片，而紧急任务C需要等待A释放锁才能进行，所以A需要立刻被执行，然后释放锁，这样C才能执行，但A获得CPU时间片的机会很少，因而间接导致了C不能被即使处理，这在实时操作系统中很可能会导致任务C超时。

- 一种可能的解决方案是当C需要上锁，而锁被A持有时，临时升高A的优先级，让A赶紧执行完毕释放锁。
